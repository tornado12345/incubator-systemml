/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.sysml.test.gpu;

import java.util.Random;
import org.junit.Test;
import org.junit.Assert;
import org.apache.sysml.api.jmlc.Connection;
import org.apache.sysml.api.jmlc.PreparedScript;


public class JMLCTests extends GPUTests {

	static class ScriptContainer {
		String dml;
		String[] inputVarNames;
	}

	@Test
	public void testJMLC() {
		try {
			Connection conn = new Connection();

			int numMatrices = 10;
			int matrixNumRows = 100;
			int numScriptInvocations = 10;

			ScriptContainer SC = generateDMLScript(numMatrices);

			PreparedScript script = conn.prepareScript(
					SC.dml, SC.inputVarNames, new String[] { "Z" }, true, true, 0);

			// execute the script without pinning input matrices between invocations
			executeDMLScript(script, numScriptInvocations, matrixNumRows, numMatrices, false);

			// execute the script while pinning input matrices between invocations
			executeDMLScript(script, numScriptInvocations, matrixNumRows, numMatrices, true);
		} catch (Exception e) {
			Assert.fail("An unexpected exception occurred: " + e.getMessage());
		}
	}

	// Generates a simple synthetic DML script which multiplies a sequence of square matrices.
	// I.e. Z = X %*% W1 %*% W2 %*% W3 ...
	// numMatrices determines the number of matrices in the sequences. The size of the matrices can be set
	// in executeDMLScript
	private static ScriptContainer generateDMLScript(int numMatrices) {
		ScriptContainer SC = new ScriptContainer();
		String[] inputVarNames = new String[numMatrices + 1];
		inputVarNames[0] = "x";

		StringBuilder dml = new StringBuilder("x = read(\"/tmp/X.mtx\", rows=-1, cols=-1)\n");
		for (int ix=0; ix<numMatrices; ix++)
		{
			String name = "W" + ix;
			inputVarNames[ix+1] = name;
			String readCmd = name + " = read(\"/tmp/" + name + ".mtx\", rows=-1, cols=-1)\n";
			dml.append(readCmd);
		}

		dml.append("Z = x %*% W0\n");
		for (int ix=1; ix<numMatrices; ix++)
		{
			String multiplyCmd = "Z = Z %*% W" + ix + "\n";
			dml.append(multiplyCmd);
		}

		dml.append("while (-1 > 1)\n    print(as.scalar(Z[1,1]))\n");

		SC.dml = dml.toString();
		SC.inputVarNames = inputVarNames;

		return SC;
	}

	// Executes a PreparedScript generated by generateDMLScript. The parameter n determines the
	// number of times the script is invoked. The parameter rows controls the shape of the matrices.
	// Set this parameter larger to use more memory. The parameter numMatrices must be set to the same value as
	// in generateDMLScript. The parameter pinWeights controls whether weight matrices should be
	// pinned in memory between script invocations.
	private static void executeDMLScript(PreparedScript script, int n, int rows, int numMatrices, boolean pinWeights) {
		for (int ix=0; ix<numMatrices; ix++)
			script.setMatrix("W" + ix, randomMatrix(rows, rows), pinWeights);

		for (int ix=0; ix<n; ix++)
		{
			script.setMatrix("x", randomMatrix(rows, rows), false);
			script.executeScript();
			if (!pinWeights)
				for (int iy=0; iy<numMatrices; iy++)
					script.setMatrix(
							"W" + iy, randomMatrix(rows, rows), false);
		}
	}

	private static double[][] randomMatrix(int rows, int cols) {
		double[][] matrix = new double[rows][cols];
		Random random = new Random(System.currentTimeMillis());
		for (int i = 0; i < rows; i++) {
			for (int j = 0; j < cols; j++) {
				matrix[i][j] = random.nextDouble();
			}
		}
		return matrix;
	}

}
